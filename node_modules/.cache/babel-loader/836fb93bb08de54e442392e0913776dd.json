{"ast":null,"code":"import \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport { Vue } from '../../../vue';\nimport { NAME_TABLE } from '../../../constants/components';\nimport { EVENT_NAME_REFRESH, EVENT_NAME_REFRESHED } from '../../../constants/events';\nimport { PROP_TYPE_ARRAY_FUNCTION, PROP_TYPE_BOOLEAN, PROP_TYPE_STRING } from '../../../constants/props';\nimport { getRootActionEventName, getRootEventName } from '../../../utils/events';\nimport { isArray, isFunction, isPromise } from '../../../utils/inspect';\nimport { looseEqual } from '../../../utils/loose-equal';\nimport { clone } from '../../../utils/object';\nimport { makeProp } from '../../../utils/props';\nimport { warn } from '../../../utils/warn';\nimport { listenOnRootMixin } from '../../../mixins/listen-on-root'; // --- Constants ---\n\nvar ROOT_EVENT_NAME_REFRESHED = getRootEventName(NAME_TABLE, EVENT_NAME_REFRESHED);\nvar ROOT_ACTION_EVENT_NAME_REFRESH = getRootActionEventName(NAME_TABLE, EVENT_NAME_REFRESH); // --- Props ---\n\nexport var props = {\n  // Passed to the context object\n  // Not used by `<b-table>` directly\n  apiUrl: makeProp(PROP_TYPE_STRING),\n  // Adds in 'Function' support\n  items: makeProp(PROP_TYPE_ARRAY_FUNCTION, []),\n  noProviderFiltering: makeProp(PROP_TYPE_BOOLEAN, false),\n  noProviderPaging: makeProp(PROP_TYPE_BOOLEAN, false),\n  noProviderSorting: makeProp(PROP_TYPE_BOOLEAN, false)\n}; // --- Mixin ---\n// @vue/component\n\nexport var providerMixin = Vue.extend({\n  mixins: [listenOnRootMixin],\n  props: props,\n  computed: {\n    hasProvider: function hasProvider() {\n      return isFunction(this.items);\n    },\n    providerTriggerContext: function providerTriggerContext() {\n      // Used to trigger the provider function via a watcher. Only the fields that\n      // are needed for triggering a provider update are included. Note that the\n      // regular this.context is sent to the provider during fetches though, as they\n      // may need all the prop info.\n      var ctx = {\n        apiUrl: this.apiUrl,\n        filter: null,\n        sortBy: null,\n        sortDesc: null,\n        perPage: null,\n        currentPage: null\n      };\n\n      if (!this.noProviderFiltering) {\n        // Either a string, or could be an object or array.\n        ctx.filter = this.localFilter;\n      }\n\n      if (!this.noProviderSorting) {\n        ctx.sortBy = this.localSortBy;\n        ctx.sortDesc = this.localSortDesc;\n      }\n\n      if (!this.noProviderPaging) {\n        ctx.perPage = this.perPage;\n        ctx.currentPage = this.currentPage;\n      }\n\n      return clone(ctx);\n    }\n  },\n  watch: {\n    // Provider update triggering\n    items: function items(newValue) {\n      // If a new provider has been specified, trigger an update\n      if (this.hasProvider || isFunction(newValue)) {\n        this.$nextTick(this._providerUpdate);\n      }\n    },\n    providerTriggerContext: function providerTriggerContext(newValue, oldValue) {\n      // Trigger the provider to update as the relevant context values have changed.\n      if (!looseEqual(newValue, oldValue)) {\n        this.$nextTick(this._providerUpdate);\n      }\n    }\n  },\n  mounted: function mounted() {\n    var _this = this; // Call the items provider if necessary\n\n\n    if (this.hasProvider && (!this.localItems || this.localItems.length === 0)) {\n      // Fetch on mount if localItems is empty\n      this._providerUpdate();\n    } // Listen for global messages to tell us to force refresh the table\n\n\n    this.listenOnRoot(ROOT_ACTION_EVENT_NAME_REFRESH, function (id) {\n      if (id === _this.id || id === _this) {\n        _this.refresh();\n      }\n    });\n  },\n  methods: {\n    refresh: function refresh() {\n      var items = this.items,\n          refresh = this.refresh; // Public Method: Force a refresh of the provider function\n\n      this.$off(EVENT_NAME_REFRESHED, refresh);\n\n      if (this.computedBusy) {\n        // Can't force an update when forced busy by user (busy prop === true)\n        if (this.localBusy && this.hasProvider) {\n          // But if provider running (localBusy), re-schedule refresh once `refreshed` emitted\n          this.$on(EVENT_NAME_REFRESHED, refresh);\n        }\n      } else {\n        this.clearSelected();\n\n        if (this.hasProvider) {\n          this.$nextTick(this._providerUpdate);\n        } else {\n          /* istanbul ignore next */\n          this.localItems = isArray(items) ? items.slice() : [];\n        }\n      }\n    },\n    // Provider related methods\n    _providerSetLocal: function _providerSetLocal(items) {\n      this.localItems = isArray(items) ? items.slice() : [];\n      this.localBusy = false;\n      this.$emit(EVENT_NAME_REFRESHED); // New root emit\n\n      if (this.id) {\n        this.emitOnRoot(ROOT_EVENT_NAME_REFRESHED, this.id);\n      }\n    },\n    _providerUpdate: function _providerUpdate() {\n      var _this2 = this; // Refresh the provider function items.\n\n\n      if (!this.hasProvider) {\n        // Do nothing if no provider\n        return;\n      } // If table is busy, wait until refreshed before calling again\n\n\n      if (this.computedBusy) {\n        // Schedule a new refresh once `refreshed` is emitted\n        this.$nextTick(this.refresh);\n        return;\n      } // Set internal busy state\n\n\n      this.localBusy = true; // Call provider function with context and optional callback after DOM is fully updated\n\n      this.$nextTick(function () {\n        try {\n          // Call provider function passing it the context and optional callback\n          var data = _this2.items(_this2.context, _this2._providerSetLocal);\n\n          if (isPromise(data)) {\n            // Provider returned Promise\n            data.then(function (items) {\n              // Provider resolved with items\n              _this2._providerSetLocal(items);\n            });\n          } else if (isArray(data)) {\n            // Provider returned Array data\n            _this2._providerSetLocal(data);\n          } else {\n            /* istanbul ignore if */\n            if (_this2.items.length !== 2) {\n              // Check number of arguments provider function requested\n              // Provider not using callback (didn't request second argument), so we clear\n              // busy state as most likely there was an error in the provider function\n\n              /* istanbul ignore next */\n              warn(\"Provider function didn't request callback and did not return a promise or data.\", NAME_TABLE);\n              _this2.localBusy = false;\n            }\n          }\n        } catch (e)\n        /* istanbul ignore next */\n        {\n          // Provider function borked on us, so we spew out a warning\n          // and clear the busy state\n          warn(\"Provider function error [\".concat(e.name, \"] \").concat(e.message, \".\"), NAME_TABLE);\n          _this2.localBusy = false;\n\n          _this2.$off(EVENT_NAME_REFRESHED, _this2.refresh);\n        }\n      });\n    }\n  }\n});","map":{"version":3,"sources":["C:/Users/ADMIN/Downloads/movi2001/interbusfronent/node_modules/bootstrap-vue/esm/components/table/helpers/mixin-provider.js"],"names":["Vue","NAME_TABLE","EVENT_NAME_REFRESH","EVENT_NAME_REFRESHED","PROP_TYPE_ARRAY_FUNCTION","PROP_TYPE_BOOLEAN","PROP_TYPE_STRING","getRootActionEventName","getRootEventName","isArray","isFunction","isPromise","looseEqual","clone","makeProp","warn","listenOnRootMixin","ROOT_EVENT_NAME_REFRESHED","ROOT_ACTION_EVENT_NAME_REFRESH","props","apiUrl","items","noProviderFiltering","noProviderPaging","noProviderSorting","providerMixin","extend","mixins","computed","hasProvider","providerTriggerContext","ctx","filter","sortBy","sortDesc","perPage","currentPage","localFilter","localSortBy","localSortDesc","watch","newValue","$nextTick","_providerUpdate","oldValue","mounted","_this","localItems","length","listenOnRoot","id","refresh","methods","$off","computedBusy","localBusy","$on","clearSelected","slice","_providerSetLocal","$emit","emitOnRoot","_this2","data","context","then","e","concat","name","message"],"mappings":";;;;;AAAA,SAASA,GAAT,QAAoB,cAApB;AACA,SAASC,UAAT,QAA2B,+BAA3B;AACA,SAASC,kBAAT,EAA6BC,oBAA7B,QAAyD,2BAAzD;AACA,SAASC,wBAAT,EAAmCC,iBAAnC,EAAsDC,gBAAtD,QAA8E,0BAA9E;AACA,SAASC,sBAAT,EAAiCC,gBAAjC,QAAyD,uBAAzD;AACA,SAASC,OAAT,EAAkBC,UAAlB,EAA8BC,SAA9B,QAA+C,wBAA/C;AACA,SAASC,UAAT,QAA2B,4BAA3B;AACA,SAASC,KAAT,QAAsB,uBAAtB;AACA,SAASC,QAAT,QAAyB,sBAAzB;AACA,SAASC,IAAT,QAAqB,qBAArB;AACA,SAASC,iBAAT,QAAkC,gCAAlC,C,CAAoE;;AAEpE,IAAIC,yBAAyB,GAAGT,gBAAgB,CAACP,UAAD,EAAaE,oBAAb,CAAhD;AACA,IAAIe,8BAA8B,GAAGX,sBAAsB,CAACN,UAAD,EAAaC,kBAAb,CAA3D,C,CAA6F;;AAE7F,OAAO,IAAIiB,KAAK,GAAG;AACjB;AACA;AACAC,EAAAA,MAAM,EAAEN,QAAQ,CAACR,gBAAD,CAHC;AAIjB;AACAe,EAAAA,KAAK,EAAEP,QAAQ,CAACV,wBAAD,EAA2B,EAA3B,CALE;AAMjBkB,EAAAA,mBAAmB,EAAER,QAAQ,CAACT,iBAAD,EAAoB,KAApB,CANZ;AAOjBkB,EAAAA,gBAAgB,EAAET,QAAQ,CAACT,iBAAD,EAAoB,KAApB,CAPT;AAQjBmB,EAAAA,iBAAiB,EAAEV,QAAQ,CAACT,iBAAD,EAAoB,KAApB;AARV,CAAZ,C,CASJ;AACH;;AAEA,OAAO,IAAIoB,aAAa,GAAGzB,GAAG,CAAC0B,MAAJ,CAAW;AACpCC,EAAAA,MAAM,EAAE,CAACX,iBAAD,CAD4B;AAEpCG,EAAAA,KAAK,EAAEA,KAF6B;AAGpCS,EAAAA,QAAQ,EAAE;AACRC,IAAAA,WAAW,EAAE,SAASA,WAAT,GAAuB;AAClC,aAAOnB,UAAU,CAAC,KAAKW,KAAN,CAAjB;AACD,KAHO;AAIRS,IAAAA,sBAAsB,EAAE,SAASA,sBAAT,GAAkC;AACxD;AACA;AACA;AACA;AACA,UAAIC,GAAG,GAAG;AACRX,QAAAA,MAAM,EAAE,KAAKA,MADL;AAERY,QAAAA,MAAM,EAAE,IAFA;AAGRC,QAAAA,MAAM,EAAE,IAHA;AAIRC,QAAAA,QAAQ,EAAE,IAJF;AAKRC,QAAAA,OAAO,EAAE,IALD;AAMRC,QAAAA,WAAW,EAAE;AANL,OAAV;;AASA,UAAI,CAAC,KAAKd,mBAAV,EAA+B;AAC7B;AACAS,QAAAA,GAAG,CAACC,MAAJ,GAAa,KAAKK,WAAlB;AACD;;AAED,UAAI,CAAC,KAAKb,iBAAV,EAA6B;AAC3BO,QAAAA,GAAG,CAACE,MAAJ,GAAa,KAAKK,WAAlB;AACAP,QAAAA,GAAG,CAACG,QAAJ,GAAe,KAAKK,aAApB;AACD;;AAED,UAAI,CAAC,KAAKhB,gBAAV,EAA4B;AAC1BQ,QAAAA,GAAG,CAACI,OAAJ,GAAc,KAAKA,OAAnB;AACAJ,QAAAA,GAAG,CAACK,WAAJ,GAAkB,KAAKA,WAAvB;AACD;;AAED,aAAOvB,KAAK,CAACkB,GAAD,CAAZ;AACD;AAlCO,GAH0B;AAuCpCS,EAAAA,KAAK,EAAE;AACL;AACAnB,IAAAA,KAAK,EAAE,SAASA,KAAT,CAAeoB,QAAf,EAAyB;AAC9B;AACA,UAAI,KAAKZ,WAAL,IAAoBnB,UAAU,CAAC+B,QAAD,CAAlC,EAA8C;AAC5C,aAAKC,SAAL,CAAe,KAAKC,eAApB;AACD;AACF,KAPI;AAQLb,IAAAA,sBAAsB,EAAE,SAASA,sBAAT,CAAgCW,QAAhC,EAA0CG,QAA1C,EAAoD;AAC1E;AACA,UAAI,CAAChC,UAAU,CAAC6B,QAAD,EAAWG,QAAX,CAAf,EAAqC;AACnC,aAAKF,SAAL,CAAe,KAAKC,eAApB;AACD;AACF;AAbI,GAvC6B;AAsDpCE,EAAAA,OAAO,EAAE,SAASA,OAAT,GAAmB;AAC1B,QAAIC,KAAK,GAAG,IAAZ,CAD0B,CAG1B;;;AACA,QAAI,KAAKjB,WAAL,KAAqB,CAAC,KAAKkB,UAAN,IAAoB,KAAKA,UAAL,CAAgBC,MAAhB,KAA2B,CAApE,CAAJ,EAA4E;AAC1E;AACA,WAAKL,eAAL;AACD,KAPyB,CAOxB;;;AAGF,SAAKM,YAAL,CAAkB/B,8BAAlB,EAAkD,UAAUgC,EAAV,EAAc;AAC9D,UAAIA,EAAE,KAAKJ,KAAK,CAACI,EAAb,IAAmBA,EAAE,KAAKJ,KAA9B,EAAqC;AACnCA,QAAAA,KAAK,CAACK,OAAN;AACD;AACF,KAJD;AAKD,GArEmC;AAsEpCC,EAAAA,OAAO,EAAE;AACPD,IAAAA,OAAO,EAAE,SAASA,OAAT,GAAmB;AAC1B,UAAI9B,KAAK,GAAG,KAAKA,KAAjB;AAAA,UACI8B,OAAO,GAAG,KAAKA,OADnB,CAD0B,CAEE;;AAE5B,WAAKE,IAAL,CAAUlD,oBAAV,EAAgCgD,OAAhC;;AAEA,UAAI,KAAKG,YAAT,EAAuB;AACrB;AACA,YAAI,KAAKC,SAAL,IAAkB,KAAK1B,WAA3B,EAAwC;AACtC;AACA,eAAK2B,GAAL,CAASrD,oBAAT,EAA+BgD,OAA/B;AACD;AACF,OAND,MAMO;AACL,aAAKM,aAAL;;AAEA,YAAI,KAAK5B,WAAT,EAAsB;AACpB,eAAKa,SAAL,CAAe,KAAKC,eAApB;AACD,SAFD,MAEO;AACL;AACA,eAAKI,UAAL,GAAkBtC,OAAO,CAACY,KAAD,CAAP,GAAiBA,KAAK,CAACqC,KAAN,EAAjB,GAAiC,EAAnD;AACD;AACF;AACF,KAvBM;AAwBP;AACAC,IAAAA,iBAAiB,EAAE,SAASA,iBAAT,CAA2BtC,KAA3B,EAAkC;AACnD,WAAK0B,UAAL,GAAkBtC,OAAO,CAACY,KAAD,CAAP,GAAiBA,KAAK,CAACqC,KAAN,EAAjB,GAAiC,EAAnD;AACA,WAAKH,SAAL,GAAiB,KAAjB;AACA,WAAKK,KAAL,CAAWzD,oBAAX,EAHmD,CAGjB;;AAElC,UAAI,KAAK+C,EAAT,EAAa;AACX,aAAKW,UAAL,CAAgB5C,yBAAhB,EAA2C,KAAKiC,EAAhD;AACD;AACF,KAjCM;AAkCPP,IAAAA,eAAe,EAAE,SAASA,eAAT,GAA2B;AAC1C,UAAImB,MAAM,GAAG,IAAb,CAD0C,CAG1C;;;AACA,UAAI,CAAC,KAAKjC,WAAV,EAAuB;AACrB;AACA;AACD,OAPyC,CAOxC;;;AAGF,UAAI,KAAKyB,YAAT,EAAuB;AACrB;AACA,aAAKZ,SAAL,CAAe,KAAKS,OAApB;AACA;AACD,OAdyC,CAcxC;;;AAGF,WAAKI,SAAL,GAAiB,IAAjB,CAjB0C,CAiBnB;;AAEvB,WAAKb,SAAL,CAAe,YAAY;AACzB,YAAI;AACF;AACA,cAAIqB,IAAI,GAAGD,MAAM,CAACzC,KAAP,CAAayC,MAAM,CAACE,OAApB,EAA6BF,MAAM,CAACH,iBAApC,CAAX;;AAEA,cAAIhD,SAAS,CAACoD,IAAD,CAAb,EAAqB;AACnB;AACAA,YAAAA,IAAI,CAACE,IAAL,CAAU,UAAU5C,KAAV,EAAiB;AACzB;AACAyC,cAAAA,MAAM,CAACH,iBAAP,CAAyBtC,KAAzB;AACD,aAHD;AAID,WAND,MAMO,IAAIZ,OAAO,CAACsD,IAAD,CAAX,EAAmB;AACxB;AACAD,YAAAA,MAAM,CAACH,iBAAP,CAAyBI,IAAzB;AACD,WAHM,MAGA;AACL;AACA,gBAAID,MAAM,CAACzC,KAAP,CAAa2B,MAAb,KAAwB,CAA5B,EAA+B;AAC7B;AACA;AACA;;AAEA;AACAjC,cAAAA,IAAI,CAAC,iFAAD,EAAoFd,UAApF,CAAJ;AACA6D,cAAAA,MAAM,CAACP,SAAP,GAAmB,KAAnB;AACD;AACF;AACF,SAzBD,CAyBE,OAAOW,CAAP;AACF;AACA;AACE;AACA;AACAnD,UAAAA,IAAI,CAAC,4BAA4BoD,MAA5B,CAAmCD,CAAC,CAACE,IAArC,EAA2C,IAA3C,EAAiDD,MAAjD,CAAwDD,CAAC,CAACG,OAA1D,EAAmE,GAAnE,CAAD,EAA0EpE,UAA1E,CAAJ;AACA6D,UAAAA,MAAM,CAACP,SAAP,GAAmB,KAAnB;;AAEAO,UAAAA,MAAM,CAACT,IAAP,CAAYlD,oBAAZ,EAAkC2D,MAAM,CAACX,OAAzC;AACD;AACF,OApCD;AAqCD;AA1FM;AAtE2B,CAAX,CAApB","sourcesContent":["import { Vue } from '../../../vue';\r\nimport { NAME_TABLE } from '../../../constants/components';\r\nimport { EVENT_NAME_REFRESH, EVENT_NAME_REFRESHED } from '../../../constants/events';\r\nimport { PROP_TYPE_ARRAY_FUNCTION, PROP_TYPE_BOOLEAN, PROP_TYPE_STRING } from '../../../constants/props';\r\nimport { getRootActionEventName, getRootEventName } from '../../../utils/events';\r\nimport { isArray, isFunction, isPromise } from '../../../utils/inspect';\r\nimport { looseEqual } from '../../../utils/loose-equal';\r\nimport { clone } from '../../../utils/object';\r\nimport { makeProp } from '../../../utils/props';\r\nimport { warn } from '../../../utils/warn';\r\nimport { listenOnRootMixin } from '../../../mixins/listen-on-root'; // --- Constants ---\r\n\r\nvar ROOT_EVENT_NAME_REFRESHED = getRootEventName(NAME_TABLE, EVENT_NAME_REFRESHED);\r\nvar ROOT_ACTION_EVENT_NAME_REFRESH = getRootActionEventName(NAME_TABLE, EVENT_NAME_REFRESH); // --- Props ---\r\n\r\nexport var props = {\r\n  // Passed to the context object\r\n  // Not used by `<b-table>` directly\r\n  apiUrl: makeProp(PROP_TYPE_STRING),\r\n  // Adds in 'Function' support\r\n  items: makeProp(PROP_TYPE_ARRAY_FUNCTION, []),\r\n  noProviderFiltering: makeProp(PROP_TYPE_BOOLEAN, false),\r\n  noProviderPaging: makeProp(PROP_TYPE_BOOLEAN, false),\r\n  noProviderSorting: makeProp(PROP_TYPE_BOOLEAN, false)\r\n}; // --- Mixin ---\r\n// @vue/component\r\n\r\nexport var providerMixin = Vue.extend({\r\n  mixins: [listenOnRootMixin],\r\n  props: props,\r\n  computed: {\r\n    hasProvider: function hasProvider() {\r\n      return isFunction(this.items);\r\n    },\r\n    providerTriggerContext: function providerTriggerContext() {\r\n      // Used to trigger the provider function via a watcher. Only the fields that\r\n      // are needed for triggering a provider update are included. Note that the\r\n      // regular this.context is sent to the provider during fetches though, as they\r\n      // may need all the prop info.\r\n      var ctx = {\r\n        apiUrl: this.apiUrl,\r\n        filter: null,\r\n        sortBy: null,\r\n        sortDesc: null,\r\n        perPage: null,\r\n        currentPage: null\r\n      };\r\n\r\n      if (!this.noProviderFiltering) {\r\n        // Either a string, or could be an object or array.\r\n        ctx.filter = this.localFilter;\r\n      }\r\n\r\n      if (!this.noProviderSorting) {\r\n        ctx.sortBy = this.localSortBy;\r\n        ctx.sortDesc = this.localSortDesc;\r\n      }\r\n\r\n      if (!this.noProviderPaging) {\r\n        ctx.perPage = this.perPage;\r\n        ctx.currentPage = this.currentPage;\r\n      }\r\n\r\n      return clone(ctx);\r\n    }\r\n  },\r\n  watch: {\r\n    // Provider update triggering\r\n    items: function items(newValue) {\r\n      // If a new provider has been specified, trigger an update\r\n      if (this.hasProvider || isFunction(newValue)) {\r\n        this.$nextTick(this._providerUpdate);\r\n      }\r\n    },\r\n    providerTriggerContext: function providerTriggerContext(newValue, oldValue) {\r\n      // Trigger the provider to update as the relevant context values have changed.\r\n      if (!looseEqual(newValue, oldValue)) {\r\n        this.$nextTick(this._providerUpdate);\r\n      }\r\n    }\r\n  },\r\n  mounted: function mounted() {\r\n    var _this = this;\r\n\r\n    // Call the items provider if necessary\r\n    if (this.hasProvider && (!this.localItems || this.localItems.length === 0)) {\r\n      // Fetch on mount if localItems is empty\r\n      this._providerUpdate();\r\n    } // Listen for global messages to tell us to force refresh the table\r\n\r\n\r\n    this.listenOnRoot(ROOT_ACTION_EVENT_NAME_REFRESH, function (id) {\r\n      if (id === _this.id || id === _this) {\r\n        _this.refresh();\r\n      }\r\n    });\r\n  },\r\n  methods: {\r\n    refresh: function refresh() {\r\n      var items = this.items,\r\n          refresh = this.refresh; // Public Method: Force a refresh of the provider function\r\n\r\n      this.$off(EVENT_NAME_REFRESHED, refresh);\r\n\r\n      if (this.computedBusy) {\r\n        // Can't force an update when forced busy by user (busy prop === true)\r\n        if (this.localBusy && this.hasProvider) {\r\n          // But if provider running (localBusy), re-schedule refresh once `refreshed` emitted\r\n          this.$on(EVENT_NAME_REFRESHED, refresh);\r\n        }\r\n      } else {\r\n        this.clearSelected();\r\n\r\n        if (this.hasProvider) {\r\n          this.$nextTick(this._providerUpdate);\r\n        } else {\r\n          /* istanbul ignore next */\r\n          this.localItems = isArray(items) ? items.slice() : [];\r\n        }\r\n      }\r\n    },\r\n    // Provider related methods\r\n    _providerSetLocal: function _providerSetLocal(items) {\r\n      this.localItems = isArray(items) ? items.slice() : [];\r\n      this.localBusy = false;\r\n      this.$emit(EVENT_NAME_REFRESHED); // New root emit\r\n\r\n      if (this.id) {\r\n        this.emitOnRoot(ROOT_EVENT_NAME_REFRESHED, this.id);\r\n      }\r\n    },\r\n    _providerUpdate: function _providerUpdate() {\r\n      var _this2 = this;\r\n\r\n      // Refresh the provider function items.\r\n      if (!this.hasProvider) {\r\n        // Do nothing if no provider\r\n        return;\r\n      } // If table is busy, wait until refreshed before calling again\r\n\r\n\r\n      if (this.computedBusy) {\r\n        // Schedule a new refresh once `refreshed` is emitted\r\n        this.$nextTick(this.refresh);\r\n        return;\r\n      } // Set internal busy state\r\n\r\n\r\n      this.localBusy = true; // Call provider function with context and optional callback after DOM is fully updated\r\n\r\n      this.$nextTick(function () {\r\n        try {\r\n          // Call provider function passing it the context and optional callback\r\n          var data = _this2.items(_this2.context, _this2._providerSetLocal);\r\n\r\n          if (isPromise(data)) {\r\n            // Provider returned Promise\r\n            data.then(function (items) {\r\n              // Provider resolved with items\r\n              _this2._providerSetLocal(items);\r\n            });\r\n          } else if (isArray(data)) {\r\n            // Provider returned Array data\r\n            _this2._providerSetLocal(data);\r\n          } else {\r\n            /* istanbul ignore if */\r\n            if (_this2.items.length !== 2) {\r\n              // Check number of arguments provider function requested\r\n              // Provider not using callback (didn't request second argument), so we clear\r\n              // busy state as most likely there was an error in the provider function\r\n\r\n              /* istanbul ignore next */\r\n              warn(\"Provider function didn't request callback and did not return a promise or data.\", NAME_TABLE);\r\n              _this2.localBusy = false;\r\n            }\r\n          }\r\n        } catch (e)\r\n        /* istanbul ignore next */\r\n        {\r\n          // Provider function borked on us, so we spew out a warning\r\n          // and clear the busy state\r\n          warn(\"Provider function error [\".concat(e.name, \"] \").concat(e.message, \".\"), NAME_TABLE);\r\n          _this2.localBusy = false;\r\n\r\n          _this2.$off(EVENT_NAME_REFRESHED, _this2.refresh);\r\n        }\r\n      });\r\n    }\r\n  }\r\n});"]},"metadata":{},"sourceType":"module"}